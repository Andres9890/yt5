name: YouTube Archive Download
on:
  repository_dispatch:
    types: [download-video]

env:
  R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
  R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
  R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
  R2_BUCKET: ${{ secrets.R2_BUCKET }}
  WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}

jobs:
  download-video:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Cache yt-dlp and dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            /opt/hostedrunner/.local/lib/python*/site-packages
          key: ${{ runner.os }}-ytdlp-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-ytdlp-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install yt-dlp boto3 requests tqdm

      - name: Decode cookies.txt from secret (required)
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.YT_COOKIES_B64 }}" ]; then
            echo "Error: YT_COOKIES_B64 secret is required but not set."
            exit 1
          fi
          echo "${{ secrets.YT_COOKIES_B64 }}" | base64 -d > /tmp/cookies.txt
          if [ ! -s /tmp/cookies.txt ]; then
            echo "Error: Decoded /tmp/cookies.txt is empty or invalid."
            exit 1
          fi
          chmod 600 /tmp/cookies.txt
          echo "COOKIES_FILE=/tmp/cookies.txt" >> $GITHUB_ENV

      - name: Create download script
        run: |
          cat << 'EOF' > download_video.py
          #!/usr/bin/env python3
          import os
          import sys
          import json
          import subprocess
          import requests
          import boto3
          from pathlib import Path
          import tempfile
          import shutil
          from datetime import datetime
          import time
          import re
          from tqdm import tqdm
          
          class ProgressHook:
              def __init__(self, video_id, webhook_url=None, job_id=None):
                  self.video_id = video_id
                  self.webhook_url = webhook_url
                  self.job_id = job_id
                  self.last_progress_update = 0
                  self.start_time = time.time()
                  
              def __call__(self, d):
                  if d['status'] == 'downloading':
                      current_time = time.time()
                      
                      # Parse progress information
                      downloaded = d.get('downloaded_bytes', 0)
                      total = d.get('total_bytes') or d.get('total_bytes_estimate', 0)
                      speed = d.get('speed', 0)
                      eta = d.get('eta', 0)
                      
                      # Calculate percentage
                      if total > 0:
                          percentage = (downloaded / total) * 100
                      else:
                          percentage = 0
                      
                      # Format sizes
                      downloaded_mb = downloaded / (1024 * 1024)
                      total_mb = total / (1024 * 1024) if total > 0 else 0
                      speed_mb = speed / (1024 * 1024) if speed else 0
                      
                      # Print progress every 5 seconds or at significant milestones
                      if (current_time - self.last_progress_update > 5 or 
                          percentage in [10, 25, 50, 75, 90] and 
                          abs(percentage - getattr(self, 'last_percentage', 0)) < 1):
                          
                          progress_msg = f"üì• Download Progress: {percentage:.1f}%"
                          if total_mb > 0:
                              progress_msg += f" ({downloaded_mb:.1f}/{total_mb:.1f} MB)"
                          if speed_mb > 0:
                              progress_msg += f" | Speed: {speed_mb:.1f} MB/s"
                          if eta:
                              progress_msg += f" | ETA: {eta}s"
                          
                          print(progress_msg)
                          
                          # Send progress webhook every 10 seconds for long downloads
                          if (current_time - self.last_progress_update > 10 and 
                              self.webhook_url and self.job_id):
                              self.send_progress_webhook(percentage, downloaded, total, speed)
                          
                          self.last_progress_update = current_time
                          self.last_percentage = percentage
                  
                  elif d['status'] == 'finished':
                      elapsed = time.time() - self.start_time
                      file_size = d.get('total_bytes', 0) / (1024 * 1024)
                      print(f"‚úÖ Download completed: {d['filename']}")
                      print(f"üìä File size: {file_size:.1f} MB | Time: {elapsed:.1f}s")
                      
                      if self.webhook_url and self.job_id:
                          self.send_progress_webhook(100, d.get('total_bytes', 0), d.get('total_bytes', 0))
              
              def send_progress_webhook(self, percentage, downloaded, total, speed=None):
                  """Send progress update via webhook"""
                  try:
                      payload = {
                          'jobId': self.job_id,
                          'videoId': self.video_id,
                          'status': 'downloading',
                          'progress': {
                              'percentage': round(percentage, 1),
                              'downloaded_bytes': downloaded,
                              'total_bytes': total,
                              'speed_bytes_per_sec': speed or 0
                          }
                      }
                      
                      response = requests.post(
                          self.webhook_url,
                          json=payload,
                          timeout=5,
                          headers={'Content-Type': 'application/json'}
                      )
                      
                      if response.status_code != 200:
                          print(f"‚ö†Ô∏è Progress webhook failed: {response.status_code}")
                          
                  except Exception as e:
                      print(f"‚ö†Ô∏è Progress webhook error: {str(e)}")
          
          def download_video(video_url, video_id, folder, job_id, webhook_url):
              """Download video using yt-dlp and upload to R2"""
              
              print(f"üöÄ Starting download for video {video_id} in folder {folder}")
              
              # Send initial status webhook
              send_webhook(webhook_url, job_id, video_id, 'started')
              
              # Create temporary directory
              with tempfile.TemporaryDirectory() as temp_dir:
                  download_path = Path(temp_dir) / "downloads"
                  download_path.mkdir(exist_ok=True)
                  
                  # Create progress hook
                  progress_hook = ProgressHook(video_id, webhook_url, job_id)
                  
                  try:
                      print(f"üîç Extracting video information...")
                      
                      # First, get video info to show what we're downloading
                      info_cmd = [
                          'yt-dlp',
                          '--dump-json',
                          '--no-download'
                      ]
                      
                      # Add cookies if available
                      cookies_file = os.environ.get('COOKIES_FILE')
                      if cookies_file and os.path.isfile(cookies_file):
                          info_cmd.extend(['--cookies', cookies_file])
                      
                      info_cmd.append(video_url)
                      
                      # Get video information
                      info_result = subprocess.run(info_cmd, capture_output=True, text=True, timeout=60)
                      
                      if info_result.returncode == 0:
                          try:
                              video_info = json.loads(info_result.stdout)
                              title = video_info.get('title', 'Unknown')
                              duration = video_info.get('duration', 0)
                              uploader = video_info.get('uploader', 'Unknown')
                              filesize = video_info.get('filesize_approx') or video_info.get('filesize', 0)
                              
                              print(f"üì∫ Video: {title}")
                              print(f"üë§ Uploader: {uploader}")
                              if duration:
                                  print(f"‚è±Ô∏è Duration: {duration // 60}:{duration % 60:02d}")
                              if filesize:
                                  print(f"üì¶ Estimated size: {filesize / (1024*1024):.1f} MB")
                          except json.JSONDecodeError:
                              print("‚ÑπÔ∏è Could not parse video info, proceeding with download...")
                      
                      print(f"‚¨áÔ∏è Starting download process...")
                      
                      # Build yt-dlp download command
                      cmd = [
                          'yt-dlp',
                          '--write-info-json',
                          '--write-description', 
                          '--write-thumbnail',
                          '--write-subs',
                          '--write-auto-subs',
                          '--all-subs',
                          '--format', 'best[height<=1080]/best',
                          '--output', str(download_path / '%(id)s.%(ext)s'),
                          '--retries', '3',
                          '--ignore-errors',
                          '--newline',  # Better progress output formatting
                      ]

                      # Add cookies if available
                      if cookies_file and os.path.isfile(cookies_file):
                          cmd.extend(['--cookies', cookies_file])

                      cmd.append(video_url)
                      
                      print(f"üîß Command: {' '.join(cmd[:8])}... [truncated]")
                      
                      # Run yt-dlp with real-time output
                      process = subprocess.Popen(
                          cmd,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.STDOUT,
                          universal_newlines=True,
                          bufsize=1
                      )
                      
                      # Monitor output for progress
                      while True:
                          output = process.stdout.readline()
                          if output == '' and process.poll() is not None:
                              break
                          if output:
                              line = output.strip()
                              print(f"yt-dlp: {line}")
                              
                              # Parse progress from yt-dlp output
                              if '[download]' in line and '%' in line:
                                  # Extract percentage from lines like "[download] 45.2% of 123.45MiB at 1.23MiB/s ETA 00:30"
                                  match = re.search(r'\[download\]\s+(\d+\.?\d*)%', line)
                                  if match:
                                      percentage = float(match.group(1))
                                      print(f"üìä Progress: {percentage:.1f}%")
                      
                      process.wait()
                      
                      if process.returncode != 0:
                          raise Exception(f"yt-dlp failed with return code {process.returncode}")
                      
                      # Find downloaded files
                      downloaded_files = list(download_path.glob('*'))
                      if not downloaded_files:
                          raise Exception("No files were downloaded")
                      
                      print(f"‚úÖ Downloaded {len(downloaded_files)} files:")
                      total_size = 0
                      for file in downloaded_files:
                          size = file.stat().st_size
                          total_size += size
                          print(f"  üìÑ {file.name} ({size / (1024*1024):.1f} MB)")
                      
                      print(f"üì¶ Total download size: {total_size / (1024*1024):.1f} MB")
                      
                      # Send upload starting webhook
                      send_webhook(webhook_url, job_id, video_id, 'uploading')
                      
                      # Extract metadata from info.json if available
                      info_file = download_path / f"{video_id}.info.json"
                      metadata = {}
                      
                      if info_file.exists():
                          with open(info_file, 'r', encoding='utf-8') as f:
                              info_data = json.load(f)
                              metadata = {
                                  'title': info_data.get('title', ''),
                                  'description': info_data.get('description', ''),
                                  'uploader': info_data.get('uploader', ''),
                                  'upload_date': info_data.get('upload_date', ''),
                                  'duration': info_data.get('duration', 0),
                                  'view_count': info_data.get('view_count', 0),
                                  'like_count': info_data.get('like_count', 0),
                                  'thumbnail': info_data.get('thumbnail', ''),
                                  'webpage_url': info_data.get('webpage_url', ''),
                                  'extractor': info_data.get('extractor', ''),
                                  'format_id': info_data.get('format_id', ''),
                                  'width': info_data.get('width', 0),
                                  'height': info_data.get('height', 0),
                                  'fps': info_data.get('fps', 0),
                                  'filesize': info_data.get('filesize', 0),
                                  'categories': info_data.get('categories', []),
                                  'tags': info_data.get('tags', []),
                                  'total_download_size': total_size,
                                  'file_count': len(downloaded_files)
                              }
                      
                      # Upload to R2
                      s3_client = boto3.client(
                          's3',
                          endpoint_url=os.environ['R2_ENDPOINT'],
                          aws_access_key_id=os.environ['R2_ACCESS_KEY_ID'],
                          aws_secret_access_key=os.environ['R2_SECRET_ACCESS_KEY']
                      )
                      
                      print("‚òÅÔ∏è Uploading files to R2...")
                      
                      # Upload with progress tracking
                      uploaded_count = 0
                      for file_path in downloaded_files:
                          # Create R2 key with folder structure: folder/video_id/filename
                          r2_key = f"{folder}/{video_id}/{file_path.name}"
                          file_size = file_path.stat().st_size
                          
                          print(f"üì§ Uploading {file_path.name} ({file_size / (1024*1024):.1f} MB)...")
                          
                          try:
                              with open(file_path, 'rb') as f:
                                  s3_client.upload_fileobj(
                                      f,
                                      os.environ['R2_BUCKET'],
                                      r2_key,
                                      ExtraArgs={
                                          'Metadata': {
                                              'video-id': video_id,
                                              'folder': str(folder),
                                              'job-id': job_id,
                                              'upload-date': datetime.now().isoformat(),
                                              'original-filename': file_path.name
                                          }
                                      }
                                  )
                              uploaded_count += 1
                              upload_progress = (uploaded_count / len(downloaded_files)) * 100
                              print(f"‚úÖ Uploaded: {r2_key} ({upload_progress:.0f}% of files)")
                              
                          except Exception as e:
                              print(f"‚ùå Failed to upload {file_path.name}: {str(e)}")
                              raise
                      
                      print(f"üéâ Successfully uploaded all {uploaded_count} files for video {video_id}")
                      return metadata
                      
                  except subprocess.TimeoutExpired:
                      raise Exception("Download timeout - video took too long to process")
                  except Exception as e:
                      print(f"‚ùå Download error: {str(e)}")
                      raise
          
          def send_webhook(webhook_url, job_id, video_id, status, metadata=None, error=None, progress=None):
              """Send completion webhook to Cloudflare Worker"""
              try:
                  payload = {
                      'jobId': job_id,
                      'videoId': video_id,
                      'status': status,
                      'timestamp': datetime.now().isoformat()
                  }
                  
                  if metadata:
                      payload['metadata'] = metadata
                  
                  if error:
                      payload['error'] = str(error)
                      
                  if progress:
                      payload['progress'] = progress
                  
                  response = requests.post(
                      webhook_url,
                      json=payload,
                      timeout=30,
                      headers={'Content-Type': 'application/json'}
                  )
                  
                  if response.status_code == 200:
                      print(f"üì° Webhook sent successfully for job {job_id} (status: {status})")
                  else:
                      print(f"‚ö†Ô∏è Webhook failed: {response.status_code} - {response.text}")
                      
              except Exception as e:
                  print(f"‚ö†Ô∏è Failed to send webhook: {str(e)}")
          
          def main():
              # Get parameters from GitHub event
              job_id = os.environ.get('JOB_ID')
              video_id = os.environ.get('VIDEO_ID')
              video_url = os.environ.get('VIDEO_URL')
              folder = int(os.environ.get('FOLDER', '0'))
              webhook_url = os.environ.get('WEBHOOK_URL')
              
              if not all([job_id, video_id, video_url, webhook_url]):
                  print("‚ùå Missing required environment variables")
                  sys.exit(1)
              
              print(f"üé¨ Processing job {job_id} for video {video_id} in folder {folder}")
              print(f"üîó Video URL: {video_url}")
              print(f"üì° Webhook URL: {webhook_url[:50]}...")
              
              try:
                  # Download and process video
                  metadata = download_video(video_url, video_id, folder, job_id, webhook_url)
                  
                  # Send success webhook
                  send_webhook(webhook_url, job_id, video_id, 'completed', metadata)
                  
                  print(f"üéâ Job {job_id} completed successfully")
                  
              except Exception as e:
                  print(f"‚ùå Job {job_id} failed: {str(e)}")
                  
                  # Send failure webhook
                  send_webhook(webhook_url, job_id, video_id, 'failed', error=str(e))
                  
                  sys.exit(1)
          
          if __name__ == "__main__":
              main()
          EOF
          
          chmod +x download_video.py

      - name: Extract event data
        id: event
        run: |
          echo "job_id=${{ github.event.client_payload.job_id }}" >> $GITHUB_OUTPUT
          echo "video_id=${{ github.event.client_payload.video_id }}" >> $GITHUB_OUTPUT
          echo "video_url=${{ github.event.client_payload.video_url }}" >> $GITHUB_OUTPUT
          echo "folder=${{ github.event.client_payload.folder }}" >> $GITHUB_OUTPUT
          echo "webhook_url=${{ github.event.client_payload.webhook_url }}" >> $GITHUB_OUTPUT

      - name: Validate inputs
        run: |
          if [ -z "${{ steps.event.outputs.job_id }}" ]; then
            echo "Error: job_id is required"
            exit 1
          fi
          if [ -z "${{ steps.event.outputs.video_id }}" ]; then
            echo "Error: video_id is required"
            exit 1
          fi
          if [ -z "${{ steps.event.outputs.video_url }}" ]; then
            echo "Error: video_url is required"
            exit 1
          fi
          if [ -z "${{ steps.event.outputs.webhook_url }}" ]; then
            echo "Error: webhook_url is required"
            exit 1
          fi

      - name: Download and process video
        env:
          JOB_ID: ${{ steps.event.outputs.job_id }}
          VIDEO_ID: ${{ steps.event.outputs.video_id }}
          VIDEO_URL: ${{ steps.event.outputs.video_url }}
          FOLDER: ${{ steps.event.outputs.folder }}
          WEBHOOK_URL: ${{ steps.event.outputs.webhook_url }}
        run: |
          echo "üöÄ Starting video processing..."
          echo "üìã Job ID: $JOB_ID"
          echo "üé• Video ID: $VIDEO_ID" 
          echo "üîó Video URL: $VIDEO_URL"
          echo "üìÅ Folder: $FOLDER"
          
          # Run the download script
          python download_video.py

      - name: Cleanup on failure
        if: failure()
        env:
          JOB_ID: ${{ steps.event.outputs.job_id }}
          VIDEO_ID: ${{ steps.event.outputs.video_id }}
          WEBHOOK_URL: ${{ steps.event.outputs.webhook_url }}
        run: |
          # Send failure notification if not already sent
          python -c "
          import requests
          import os
          from datetime import datetime
          try:
              requests.post(
                  os.environ['WEBHOOK_URL'],
                  json={
                      'jobId': os.environ['JOB_ID'],
                      'videoId': os.environ['VIDEO_ID'],
                      'status': 'failed',
                      'error': 'Workflow failed during execution',
                      'timestamp': datetime.now().isoformat()
                  },
                  timeout=10
              )
              print('‚ùå Failure webhook sent')
          except Exception as e:
              print(f'‚ö†Ô∏è Failed to send failure webhook: {e}')
          "

      - name: Log completion
        if: success()
        run: |
          echo "‚úÖ Video processing completed successfully"
          echo "üìã Job ID: ${{ steps.event.outputs.job_id }}"
          echo "üé• Video ID: ${{ steps.event.outputs.video_id }}"
          echo "üìÅ Folder: ${{ steps.event.outputs.folder }}"